#Setting the directory
setwd("C:/Users/MMD/Desktop/MS ESILV/Projet-Fil Rouge/Etape 2/first_kick_FR_S2")
#Installing packages/libraries
install.packages("xlsx") 
library("xlsx")
library(stringr)
#Loading file
file6<- read.xlsx('TriangleGlobalAutoRC V3bis.xlsx',sheetIndex = 1, header=TRUE, colClasses=NA)
#Get 3 files : Reg sinistres, provision, primes
reg_sin <- file6
prov    <- file6
prime   <- file6
k=0
for (i in 1:(dim(file6)[1]/3)) {
  reg_sin <- reg_sin[-c(i*3-k*2,i*3-1-k*2)  ,]
  prov    <- prov   [-c(i*3-k*2,i*3-2-k*2)  ,]
  prime   <- prime  [-c(i*3-1-k*2,i*3-2-k*2),]
  k=k+1
}
#Changing years into periods (in years)
reg_sin[,1] = seq(4,11,1)
prov   [,1] = seq(4,11,1)
prime  [,1] = seq(4,11,1)
#Inversing columns and rows
reg_sin <- as.data.frame(t(reg_sin))
prov    <- as.data.frame(t(prov   ))
prime   <- as.data.frame(t(prime  ))
#Changing columns names from Vi into periods added
for(i in 1:dim(reg_sin)[2]) {
  names(reg_sin)[i]<-reg_sin[1,i]
}

for(i in 1:dim(prov)[2]) {
  names(prov)[i]<-prov[1,i]
}

for(i in 1:dim(prime)[2]) {
  names(prime)[i]<-prime[1,i]
}
#Deleting the first line as it was set as columns names
reg_sin <- reg_sin[-1,]
prov    <- prov   [-1,]
prime   <- prime  [-1,]
#Deleting the "X" from the rows names
for(i in 1:dim(reg_sin)[1]) {
  row.names(reg_sin)[i]<-str_sub(row.names(reg_sin)[i], 2, 5)
}

for(i in 1:dim(prov)[1]) {
  row.names(prov)[i]<-str_sub(row.names(prov)[i], 2, 5)
}

for(i in 1:dim(prime)[1]) {
  row.names(prime)[i]<-str_sub(row.names(prime)[i], 2, 5)
}
#Add columns representing a period of 0 years to 4 years
Addedcol1<-data.frame(matrix(data=0,nrow=12,ncol=4))
Addedcol2<-data.frame(matrix(data=0,nrow=12,ncol=4))
Addedcol3<-data.frame(matrix(data=0,nrow=12,ncol=4))

names(Addedcol1)<-c(0,1,2,3)
names(Addedcol2)<-c(0,1,2,3)
names(Addedcol3)<-c(0,1,2,3)

reg_sin <-cbind(reg_sin,Addedcol1)
prov    <-cbind(prov   ,Addedcol2)
prime   <-cbind(prime  ,Addedcol3)
#Placing the added columns at the beginning of the matrix
neworder <- c(9,10,11,12,1,2,3,4,5,6,7,8)
reg_sin  <- reg_sin[,neworder]
prov     <- prov[,neworder]
prime    <- prime[,neworder]
#reordering the data based on the added columns
##researching the index for each row
index<-c(0,0,0,0,0,0,0,0)
for(i in 5:dim(reg_sin)[1]) {
  k=1
  j=1
  while (k==1 && j<=dim(reg_sin)[2]) {
    if ((as.integer(reg_sin[i,j])==0)==TRUE) {
      j=j+1
    }
    else {
      k=j
    }
  }
  index[i-4]=k
}
index
##Reordering
index2<-c(5,5,5)
index3<-c(index2,index)

for (i in 2:dim(reg_sin)[1]) {
  draftrow1<-reg_sin[i,]
  draftrow2<-prov   [i,]
  draftrow3<-prime  [i,]
  for (j in (index3[i-1]-(i-1)):(dim(reg_sin)[2]-(i-1))) {
    reg_sin[i,j]<-draftrow1[j+i-1]
    prov   [i,j]<-draftrow2[j+i-1]
    prime  [i,j]<-draftrow3[j+i-1]
  }
  for (k in (dim(reg_sin)[2]-(i-2)):dim(reg_sin)[2]) {
    reg_sin[i,k]<-NA
    prov   [i,k]<-NA
    prime  [i,k]<-NA
  }
}
#Turn the data to cumulative paid claims
reg_sin_cum<-reg_sin
#Estimation with chain ladder method
install.packages('ChainLadder', dependencies = TRUE)
library(ChainLadder)
reg_sin_cum_est<-reg_sin_cum
n=ncol(reg_sin_cum_est)
L=rep(NA,n-1)
for(j in 5:(n-1)){
  L[j]=sum(reg_sin_cum[1:(n-j),j+1])/sum(reg_sin_cum[1:(n-j),j])
  reg_sin_cum_est[(n-j+1):n,j+1]=L[j]*reg_sin_cum_est[(n-j+1):n,j]
}
k=3
for (j in 1:4) {
  L[j]=sum(reg_sin_cum[(j+k+1):(n-j),j+1])/sum(reg_sin_cum[(j+k+1):(n-j),j])
  reg_sin_cum_est[(n-j+1):n,j+1]=L[j]*reg_sin_cum_est[(n-j+1):n,j]
  k=k-2
}
sum(reg_sin_cum[5:(11),2])/sum(reg_sin_cum[5:11,1])
estimation<-as.matrix(reg_sin_cum_est)
dimnames(estimation)[1]
dimnames(estimation) <- list(origin=rownames(estimation), dev=1:ncol(estimation))
estimation <- as.triangle(estimation)
plot(estimation)
#Plotting developments for cumulative data
reg_sin_cum<-as.matrix(reg_sin_cum)
dimnames(reg_sin_cum)[1]
dimnames(reg_sin_cum) <- list(origin=rownames(reg_sin_cum), dev=1:ncol(reg_sin_cum))
reg_sin_cum <- as.triangle(reg_sin_cum)
plot(reg_sin_cum)
plot(reg_sin_cum,lattice=TRUE)
#Mackchainladder
M <- MackChainLadder(reg_sin_cum, est.sigma = "Mack")
M
#Switch to an incremental data
reg_sin_inc <- cum2incr(reg_sin_cum)
plot(reg_sin_inc)
plot(reg_sin_inc,lattice=TRUE)
#Case in which we can suppose that  the oldest origin year is not fully developed
dev_periode <- 1:11
plot(log(L-1) ~ dev_periode, main="Extrapollation Log-Linéaire des facteurs")
modele <- lm(log(L-1) ~ dev_periode)
abline(modele)
coeff <- coef(modele)
## extrapolate another 100 dev. period
extrap <- exp(coeff[1] + c(12:(12 + 100)) * coeff[2]) + 1
L_extrap <- prod(extrap)
L_extrap
plot(100*(rev(1/cumprod(rev(c(L, extrap[extrap>1.0001]))))), t="b",
        main="Modèle de développement des sinistres attendus",
        xlab="Période de développement", ylab="Développement en % de la perte finale")
#Triangle par extrapollation
L1 <- c(L, L_extrap)
file_re_re_mod_del_year_cum_extrap <- cbind(file_re_re_mod_del_year_cum, final = rep(0, 8))
for(i in 1:8){
  file_re_re_mod_del_year_cum_extrap[(8-i+1):n, i+1] <- file_re_re_mod_del_year_cum_extrap[(8-i+1):8,i]*L1[i]
}
round(file_re_re_mod_del_year_cum_extrap)
sum(file_re_re_mod_del_year_cum_extrap[ ,9] - getLatestCumulative(as.matrix(file_re_re_mod_del_year_cum)))
